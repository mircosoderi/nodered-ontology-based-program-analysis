{
  "@context": {
    "schema": "https://schema.org/",
    "nrua": "https://w3id.org/nodered-static-program-analysis/user-application-ontology#"
  },
  "@id": "urn:nrua:rules",
  "@graph": [
    {
      "@id": "urn:rule:node-type-title-seeAlso",
      "@type": [
        "nrua:Rule"
      ],
      "schema:name": "[SPARQL] Node type mentioned in document title → schema:seeAlso (issues+forum, context-aware)",
      "schema:description": "Links each Node-RED node from the application graph (`urn:nrua:app`) to external knowledge documents (from `urn:graph:issues` and `urn:graph:forum`) whose `schema:title` mentions the node's `nrua:type` (case-insensitive substring match). Emits `schema:seeAlso(node, document)` into the inferred graph. If a document declares runtime constraints via `schema:about` (OperatingSystem, NodeJs, NodeRed), the link is kept only when at least one declared constraint in that dimension matches the current runtime environment graph (`urn:nrua:env`). If a document declares no constraints for a dimension, that dimension does not block the match.",
      "schema:programmingLanguage": "SPARQL",
      "schema:encodingFormat": "application/sparql-query",
      "schema:text": "SELECT DISTINCT ?s ?p ?o WHERE {\n  GRAPH <urn:nrua:app> {\n    ?s <https://w3id.org/nodered-static-program-analysis/user-application-ontology#type> ?t .\n  }\n\n  # Candidate knowledge documents: union of the issues graph and the forum graph.\n  {\n    GRAPH <urn:graph:issues> {\n      ?o a <https://schema.org/DigitalDocument> ;\n         <https://schema.org/title> ?title .\n    }\n  }\n  UNION\n  {\n    GRAPH <urn:graph:forum> {\n      ?o a <https://schema.org/DigitalDocument> ;\n         <https://schema.org/title> ?title .\n    }\n  }\n\n  # Runtime environment facts (computed at startup into urn:nrua:env).\n  GRAPH <urn:nrua:env> {\n    ?nodejsEnv a <https://w3id.org/nodered-static-program-analysis/user-application-ontology#NodeJs> ;\n               <https://schema.org/version> ?nodejsVerEnv ;\n               <https://schema.org/operatingSystem> ?osEnv .\n\n    ?osEnv a <https://schema.org/OperatingSystem> ;\n           <https://schema.org/name> ?osNameEnv .\n\n    ?noderedEnv a <https://w3id.org/nodered-static-program-analysis/user-application-ontology#NodeRed> ;\n                <https://schema.org/version> ?noderedVerEnv .\n  }\n\n  # Base match condition: the node's nrua:type must appear in the document title (case-insensitive substring).\n  FILTER(CONTAINS(LCASE(STR(?title)), LCASE(STR(?t))))\n\n  # -----------------------------------------------------------------------------\n  # Context gating: if a document declares OS/Node.js/Node-RED constraints via schema:about, require at least one match.\n  # -----------------------------------------------------------------------------\n  # OS gating: reject only when at least one OS constraint exists AND none matches the current env OS name.\n  FILTER NOT EXISTS {\n    {\n      GRAPH <urn:graph:issues> {\n        ?o <https://schema.org/about> ?aboutOsAny .\n        ?aboutOsAny a <https://schema.org/OperatingSystem> ;\n                    <https://schema.org/name> ?osNameAny .\n      }\n    }\n    UNION\n    {\n      GRAPH <urn:graph:forum> {\n        ?o <https://schema.org/about> ?aboutOsAny .\n        ?aboutOsAny a <https://schema.org/OperatingSystem> ;\n                    <https://schema.org/name> ?osNameAny .\n      }\n    }\n\n    FILTER NOT EXISTS {\n      {\n        GRAPH <urn:graph:issues> {\n          ?o <https://schema.org/about> ?aboutOsMatch .\n          ?aboutOsMatch a <https://schema.org/OperatingSystem> ;\n                        <https://schema.org/name> ?osNameNeed .\n          FILTER(LCASE(STR(?osNameNeed)) = LCASE(STR(?osNameEnv)))\n        }\n      }\n      UNION\n      {\n        GRAPH <urn:graph:forum> {\n          ?o <https://schema.org/about> ?aboutOsMatch .\n          ?aboutOsMatch a <https://schema.org/OperatingSystem> ;\n                        <https://schema.org/name> ?osNameNeed .\n          FILTER(LCASE(STR(?osNameNeed)) = LCASE(STR(?osNameEnv)))\n        }\n      }\n    }\n  }\n\n  # Node.js gating: reject only when at least one NodeJs version constraint exists AND none matches env (case-insensitive substring).\n  FILTER NOT EXISTS {\n    {\n      GRAPH <urn:graph:issues> {\n        ?o <https://schema.org/about> ?aboutNodejsAny .\n        ?aboutNodejsAny a <https://w3id.org/nodered-static-program-analysis/user-application-ontology#NodeJs> ;\n                        <https://schema.org/version> ?nodejsVerAny .\n      }\n    }\n    UNION\n    {\n      GRAPH <urn:graph:forum> {\n        ?o <https://schema.org/about> ?aboutNodejsAny .\n        ?aboutNodejsAny a <https://w3id.org/nodered-static-program-analysis/user-application-ontology#NodeJs> ;\n                        <https://schema.org/version> ?nodejsVerAny .\n      }\n    }\n\n    FILTER NOT EXISTS {\n      {\n        GRAPH <urn:graph:issues> {\n          ?o <https://schema.org/about> ?aboutNodejsMatch .\n          ?aboutNodejsMatch a <https://w3id.org/nodered-static-program-analysis/user-application-ontology#NodeJs> ;\n                            <https://schema.org/version> ?nodejsVerNeed .\n          FILTER(CONTAINS(LCASE(STR(?nodejsVerEnv)), LCASE(STR(?nodejsVerNeed))))\n        }\n      }\n      UNION\n      {\n        GRAPH <urn:graph:forum> {\n          ?o <https://schema.org/about> ?aboutNodejsMatch .\n          ?aboutNodejsMatch a <https://w3id.org/nodered-static-program-analysis/user-application-ontology#NodeJs> ;\n                            <https://schema.org/version> ?nodejsVerNeed .\n          FILTER(CONTAINS(LCASE(STR(?nodejsVerEnv)), LCASE(STR(?nodejsVerNeed))))\n        }\n      }\n    }\n  }\n\n  # Node-RED gating: reject only when at least one NodeRed version constraint exists AND none matches env (case-insensitive substring).\n  FILTER NOT EXISTS {\n    {\n      GRAPH <urn:graph:issues> {\n        ?o <https://schema.org/about> ?aboutNoderedAny .\n        ?aboutNoderedAny a <https://w3id.org/nodered-static-program-analysis/user-application-ontology#NodeRed> ;\n                         <https://schema.org/version> ?noderedVerAny .\n      }\n    }\n    UNION\n    {\n      GRAPH <urn:graph:forum> {\n        ?o <https://schema.org/about> ?aboutNoderedAny .\n        ?aboutNoderedAny a <https://w3id.org/nodered-static-program-analysis/user-application-ontology#NodeRed> ;\n                         <https://schema.org/version> ?noderedVerAny .\n      }\n    }\n\n    FILTER NOT EXISTS {\n      {\n        GRAPH <urn:graph:issues> {\n          ?o <https://schema.org/about> ?aboutNoderedMatch .\n          ?aboutNoderedMatch a <https://w3id.org/nodered-static-program-analysis/user-application-ontology#NodeRed> ;\n                             <https://schema.org/version> ?noderedVerNeed .\n          FILTER(CONTAINS(LCASE(STR(?noderedVerEnv)), LCASE(STR(?noderedVerNeed))))\n        }\n      }\n      UNION\n      {\n        GRAPH <urn:graph:forum> {\n          ?o <https://schema.org/about> ?aboutNoderedMatch .\n          ?aboutNoderedMatch a <https://w3id.org/nodered-static-program-analysis/user-application-ontology#NodeRed> ;\n                             <https://schema.org/version> ?noderedVerNeed .\n          FILTER(CONTAINS(LCASE(STR(?noderedVerEnv)), LCASE(STR(?noderedVerNeed))))\n        }\n      }\n    }\n  }\n\n  BIND(<https://schema.org/seeAlso> AS ?p)\n}\n"
    },
    {
      "@id": "urn:rule:appflow-cookbookflow-keywords-perfect-overlap-seeAlso",
      "@type": [
        "nrua:Rule"
      ],
      "schema:name": "[SPARQL] Flow keyword signature match (app Flow ↔ cookbook SoftwareSourceCode) → schema:seeAlso",
      "schema:description": "For each application Flow in `urn:nrua:app`, links it to a cookbook/library `schema:SoftwareSourceCode` entry in `urn:graph:flowslib` when the `schema:keywords` value matches exactly. The system assumes `schema:keywords` is already normalized into a canonical signature (sorted, comma-separated) when building the application graph.",
      "schema:programmingLanguage": "SPARQL",
      "schema:encodingFormat": "application/sparql-query",
      "schema:text": "PREFIX schema: <https://schema.org/>\nPREFIX nrua: <https://w3id.org/nodered-static-program-analysis/user-application-ontology#>\n\nSELECT DISTINCT ?s ?p ?o\nWHERE {\n  GRAPH <urn:nrua:app> {\n    ?s a nrua:Flow ;\n       schema:keywords ?kwSig .\n  }\n\n  GRAPH <urn:graph:flowslib> {\n    ?o a schema:SoftwareSourceCode ;\n       schema:keywords ?kwSig .\n  }\n\n  BIND(<https://schema.org/seeAlso> AS ?p)\n}\n"
    },
    {
      "@id": "urn:rule:anyresource-same-schema-name-sameAs",
      "@type": [
        "nrua:Rule"
      ],
      "schema:name": "[SPARQL] Same schema:name within app graph → schema:sameAs (heuristic)",
      "schema:description": "Within the application graph (`urn:nrua:app`), finds pairs of distinct resources that share the exact same `schema:name` literal and asserts `schema:sameAs(s, o)`. This is a lightweight heuristic for prototyping entity linking; consider adding stronger constraints (e.g., same class, same flow context, normalized names) in production.",
      "schema:programmingLanguage": "SPARQL",
      "schema:encodingFormat": "application/sparql-query",
      "schema:text": "SELECT DISTINCT ?s ?p ?o\nWHERE {\n  GRAPH <urn:nrua:app> {\n    ?s <https://schema.org/name> ?name .\n    ?o <https://schema.org/name> ?name .\n\n    ?s a ?sClass .\n    ?o a ?oClass .\n\n    VALUES ?sClass {\n      <https://w3id.org/nodered-static-program-analysis/user-application-ontology#Node>\n      <https://w3id.org/nodered-static-program-analysis/user-application-ontology#Flow>\n    }\n\n    VALUES ?oClass {\n      <https://w3id.org/nodered-static-program-analysis/user-application-ontology#Node>\n      <https://w3id.org/nodered-static-program-analysis/user-application-ontology#Flow>\n    }\n\n    FILTER(?s != ?o)\n  }\n\n  BIND(<https://schema.org/sameAs> AS ?p)\n}\n"
    },
    {
      "@id": "urn:rule:flow-loop-warning-nodes-only",
      "@type": [
        "nrua:Rule"
      ],
      "schema:name": "[N3+SPARQL] Detect wiring cycles in a flow → schema:comment warning (Nodes only)",
      "schema:description": "Detects wiring cycles (loops) among Nodes in the application graph. The SPARQL projection extracts a minimal set of facts (types + wiring) and derives helper edges `urn:nrua:pv:edge` (Node→Node). The N3 program computes reachability and marks nodes that can reach themselves, then emits a user-facing `schema:comment` warning. Helper predicates under `urn:nrua:pv:*` are internal and are filtered out from the final inferred graph unless explicitly converted into user-facing triples.",
      "schema:programmingLanguage": "N3",
      "schema:encodingFormat": "text/n3",
      "schema:text": "# Reachability base: every derived edge implies reachability.\n{ ?a <urn:nrua:pv:edge> ?b } => { ?a <urn:nrua:pv:path> ?b } .\n\n# Reachability transitive closure: reachability is propagated along edges.\n{ ?a <urn:nrua:pv:path> ?b . ?b <urn:nrua:pv:edge> ?c } => { ?a <urn:nrua:pv:path> ?c } .\n\n# Cycle detection: a node is in a loop if it can reach itself.\n{ ?n <urn:nrua:pv:path> ?n } => { ?n <urn:nrua:pv:inLoop> \"true\" } .\n\n# User-facing output (Nodes only): attach a warning comment to nodes in cycles.\n{ ?n <urn:nrua:pv:inLoop> \"true\" } => { ?n <https://schema.org/comment> \"This element is part of a loop.\" } .\n",
      "schema:hasPart": [
        {
          "@type": "schema:SoftwareSourceCode",
          "schema:programmingLanguage": "SPARQL",
          "schema:encodingFormat": "application/sparql-query",
          "schema:text": "PREFIX nrua: <https://w3id.org/nodered-static-program-analysis/user-application-ontology#>\n\nSELECT ?s ?p ?o\nWHERE {\n  GRAPH <urn:nrua:app> {\n    # Minimal rdf:type facts used by the N3 program.\n    { ?s a nrua:Node       BIND(<http://www.w3.org/1999/02/22-rdf-syntax-ns#type> AS ?p) BIND(nrua:Node AS ?o) }\n    UNION\n    { ?s a nrua:NodeOutput BIND(<http://www.w3.org/1999/02/22-rdf-syntax-ns#type> AS ?p) BIND(nrua:NodeOutput AS ?o) }\n\n    # Wiring predicates used to traverse connections.\n    UNION\n    { ?s nrua:hasOutput ?o BIND(nrua:hasOutput AS ?p) }\n    UNION\n    { ?s nrua:toNode ?o    BIND(nrua:toNode AS ?p) }\n\n    # Derived helper predicate: direct Node→Node edges (used for reachability).\n    UNION\n    {\n      ?n nrua:hasOutput ?out .\n      ?out nrua:toNode ?m .\n      BIND(?n AS ?s)\n      BIND(<urn:nrua:pv:edge> AS ?p)\n      BIND(?m AS ?o)\n    }\n  }\n}\n"
        }
      ]
    },
    {
      "@id": "urn:rule:function-node-missing-output-warning",
      "@type": [
        "nrua:Rule"
      ],
      "schema:name": "[N3+SPARQL] Function node with no outputs → schema:comment warning",
      "schema:description": "Flags Node-RED Function nodes that have no outgoing wiring. The SPARQL projection emits an internal flag triple `urn:nrua:pv:functionMissingOutput \"true\"`, and the N3 program converts that into a user-facing `schema:comment` warning on the node.",
      "schema:programmingLanguage": "N3",
      "schema:encodingFormat": "text/n3",
      "schema:text": "{ ?n <urn:nrua:pv:functionMissingOutput> \"true\" } => { ?n <https://schema.org/comment> \"There may be a link missing in output from this function node.\" } .\n",
      "schema:hasPart": [
        {
          "@type": "schema:SoftwareSourceCode",
          "schema:programmingLanguage": "SPARQL",
          "schema:encodingFormat": "application/sparql-query",
          "schema:text": "PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>\nPREFIX schema: <https://schema.org/>\nPREFIX nrua: <https://w3id.org/nodered-static-program-analysis/user-application-ontology#>\n\nSELECT ?s ?p ?o\nWHERE {\n  GRAPH <urn:nrua:app> {\n    ?n rdf:type nrua:Node .\n    ?n nrua:type \"function\" .\n    FILTER NOT EXISTS { ?n nrua:hasOutput ?out }\n\n    BIND(?n AS ?s)\n    BIND(<urn:nrua:pv:functionMissingOutput> AS ?p)\n    BIND(\"true\" AS ?o)\n  }\n}\n"
        }
      ]
    }
  ]
}

